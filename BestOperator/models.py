__author__ = 'Kostiantyn Bezverkhyi'

from django.core.urlresolvers import NoReverseMatch, reverse
from django.db import models
from django.utils.translation import ugettext_lazy as _

class DescriptionModel(models.Model):
    description = models.TextField(blank = True, verbose_name=_("Description"), help_text=_("Any useful information which may be helpful to easily operate current object."))
    def get_admin_url(self):
        """
        Returns the admin URL to edit the object represented by this log entry.
        """
        if self._meta.app_label and self._meta.model_name:
            info = (self._meta.app_label, self._meta.model_name)
            try:
                return reverse('admin:%s_%s_change' % info, args=(self.pk,))
            except NoReverseMatch:
                pass
        return None
    def get_absolute_url(self):
        return self.get_admin_url()#'http://' + get_absolute_url() + self.get_admin_url()
    def get_absolute_url_link(self):
        return '<a href="%(link)s">%(text)s</a>' % {'link' : self.get_absolute_url(), 'text' : self.__str__()}
    get_absolute_url_link.description = _('URL')
    get_absolute_url_link.allow_tags = True
    def gab(self):#shortcut for self.get_absolute_url_link()
        return self.get_absolute_url_link()
    gab.short_description = _('Object')
    gab.allow_tags = True
    def get_pk(self):
        return self.pk
    get_pk.short_description = _('ID')
    def remove(self):
        return '<a class="inline-deletelink" title="delete" href="%s/delete/"></a>' % (self.pk)
    remove.short_description = ''
    remove.allow_tags = True
    class Meta:
        abstract = True

class NameDescrModel(DescriptionModel):
    name = models.CharField(max_length=200, verbose_name=_("Name"), help_text=_("Name of the current object."))
    def __str__(self):
        return self.name
    class Meta:
        abstract = True

class NameDescrAutoGeneratedModel(DescriptionModel):# Translators: This field should have the same name all the time?
    name = models.CharField(max_length=200, verbose_name=_("Name"), default=_("<auto-generated>"), editable=False, help_text=_("Name of the current object."))
    def save(self, *args, **kwargs):
        if self.get_name():
            self.name = self.get_name()
        super(NameDescrAutoGeneratedModel, self).save(*args, **kwargs)
    class Meta:
        abstract = True

class Code(NameDescrModel):
    operator_code = models.CharField(max_length=10, verbose_name=_("Operator Code"),
                                     help_text=_("Operator code - several first digits of phone number for some specific operator"))
    operator = models.ForeignKey('Operator', related_name='code', verbose_name= _("Operator"),
                                 help_text=_("Reference to operator which uses current code."))
    def __str__(self):
        return self.operator_code
    class Meta:
        verbose_name = _("Code")
        verbose_name_plural = _("Codes")

class Operator(NameDescrModel):
    location = models.ForeignKey('Location', verbose_name=_("Location"),
                                 help_text=_("Reference to location where this operator provides services."))#TODO location could me multiple??
    link = models.TextField(blank=True, verbose_name=_("Link"), help_text=_("Link to the site where current operator resides."))
    class Meta:
        unique_together = (("name", "location"),)
        verbose_name = _("Operator")
        verbose_name_plural = _("Operators")

class PackageType(NameDescrModel):
    pass

class Package(NameDescrModel):
    price = models.DecimalField(_("Initial price"), max_digits=7, decimal_places=2, default=0, help_text=_("Initial price of package. Price that you pay when buy a new sim-card."))
    operator = models.ForeignKey('Operator', related_name='package', verbose_name=_("Operator"),
                                 help_text=_("Reference to related Operator."))
    package_type = models.ForeignKey('PackageType', verbose_name=_('Package Type'),
                                     help_text=_("Some specific Package Type: Prepayment, Contract, Business etc."))
    po_term = models.ForeignKey('POTerm', verbose_name=_('Package/Offer Term'), null=True, blank=True,
                                help_text=_("Time term of package usage/order"))
    link = models.TextField(blank=True, verbose_name=_("Link"), help_text=_("Link to the site with current package"))
    class Meta:
        unique_together = (("name", "operator"),)
        ordering = ('package_type__name', 'operator__name', )
        verbose_name = _("Package")
        verbose_name_plural = _("Packages")

class Offer(NameDescrModel):
    package = models.ManyToManyField('Package', verbose_name=_("Package"), help_text=_("Reference to related package"))
    po_term = models.ForeignKey('POTerm', verbose_name=_('Package / Offer Term'), help_text=_("Time term of offer usage/order"))
    link = models.TextField(blank=True)
    def packages(self):
        return ", ".join(p.name for p in self.package.all())
    class Meta:
        ordering = ('name', 'po_term__is_active')
        verbose_name = _("Offer")
        verbose_name_plural = _("Offers")

class POTerm(NameDescrAutoGeneratedModel):
    active_from_date = models.DateField(null=True, blank=True, verbose_name=_("Active from"), help_text=_("Package/Offer is in service from this date"))
    active_to_date = models.DateField(null=True, blank=True, verbose_name=_("Active to"), help_text=_("Package/Offer is in service this this date"))
    order_from_date = models.DateField(null=True, blank=True, verbose_name=_("Order from"), help_text=_("Package/Offer can be bought from this date"))
    order_to_date = models.DateField(null=True, blank=True, verbose_name=_("Order to"), help_text=_("Package/Offer can be bought till this date"))
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"), help_text=_("Whether this term is in use or not"))
    def __str__(self):
        if not self.is_active:
            return _('Not active')
        res_str = _('Active ')
        if self.active_from_date:
            if self.active_to_date:
                res_str += _(" from %(from_date)s to %(to_date)s") % {'from_date' : self.active_from_date, 'to_date' : self.active_to_date}
            else:
                res_str += _(' from %s') % (self.active_from_date)
        else:
            res_str += _(' forever')
        if self.order_from_date:
            res_str += _(' order ')
            if self.order_to_date:
                res_str += _(' from %(order_from)s to %(order_to)s') % {'order_from' : self.order_from_date, 'order_to' : self.order_to_date}
            else:
                res_str += _(' from %s') % (self.order_from_date)
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        verbose_name = _("Package / Offer Term")
        verbose_name_plural = _("Package / Offer Terms")
        ordering = ('-active_to_date', 'active_from_date', )

class Period(NameDescrModel):
    num_of_days = models.IntegerField(_("Number of days"), null=True, blank=True, help_text=_("Number of day for current period."))#TODO why fields are of DateTime type instead of Date??
    from_time = models.DateTimeField(null=True, blank=True,verbose_name=_("From Time"),
                                     help_text=_("Period of time when Offer/Feature is active. For example: from 01.00"))
    to_time = models.DateTimeField(null=True, blank=True, verbose_name=_("To Time"),
                                   help_text=_("Period of time when Offer/Feature is active. For example: to 08.00"))
    def __str__(self):
        res_str = self.name
        if (self.from_time or self.to_time):
            res_str += _('(%(from)s to %(to)s)') % {'from' : self.from_time.date() if self.from_time else '<->', 'to' : self.to_time.date() if self.to_time else '<->'}
        return res_str
    class Meta:
        ordering = ('-to_time', 'num_of_days', )
        verbose_name = _("Period")
        verbose_name_plural = _("Periods")

class Payment(NameDescrAutoGeneratedModel):
    price = models.DecimalField("Price", max_digits=7, decimal_places=2, default=0, help_text="Price of Offer/Feature")
    period = models.ForeignKey('Period', null=True, blank = True, help_text="Reference to Period for current Offer/Feature")
    term_of_usage = models.ForeignKey('TermOfUsage', null=True, blank = True, help_text="Reference to Term Of Usage")
    feature = models.ForeignKey('Feature', null=True, blank=True, help_text="Reference to Feature")
    offer = models.ForeignKey('Offer', null=True, blank=True, help_text="Reference to Offer")
    def __str__(self):
        ret_str = "Price"
        if self.offer:
            ret_str += " of %(offer)s" % {'offer' : self.offer}
        if self.feature:
            ret_str += " (%(feature)s)" % {'feature' : self.feature}
        if self.period:
            ret_str += " for %(period)s" % {'period' : self.period}
        return ret_str
    def get_name(self):
        return self.__str__()
    class Meta:
        ordering = ('price', 'feature__offer__name', 'offer__name', )
        verbose_name = _("Payment")
        verbose_name_plural = _("Payments")

class TermOfUsage(NameDescrAutoGeneratedModel):
    """
    This table represents possible terms of using some feature/offer. For example: 10 first minutes for one price, 11 and next minutes have another price
    """
    amount = models.IntegerField("Amount", help_text="Limit to the amount of some service")
    unit = models.ForeignKey('Unit', verbose_name="Measurement Units", help_text="Measurement units for the amount field value.")
    criterion = models.ForeignKey('Criterion', verbose_name="Criterion",
                                  help_text="Criterion to evaluate, if set to 'true' -> use current term")
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type", help_text="Service type linked to current term")
    def __str__(self):
        return '%(criterion)s %(amount)s %(unit)s (%(st)s)' % {'criterion' : self.criterion, 'amount' : self.amount, 'unit' : self.unit, 'st' : self.service_type}
    def get_name(self):
        return self.__str__()
    class Meta:
        ordering = ('criterion__name', 'amount', 'unit')
        verbose_name = _("Term Of Usage")
        verbose_name_plural = _("Terms Of Usage")

class Unit(NameDescrModel):
    unit = models.CharField(max_length=200, verbose_name="Unit", help_text="Units used for measurement")
    compared_to = models.ForeignKey('self', related_name="linked_unit", null=True, blank=True, verbose_name="Compared to unit", help_text="If compare this unit to another one")
    multiplier = models.FloatField(default=1, verbose_name="Multiply 'compared to unit'", help_text="Multiplier used to compare to values (formula is : compared_to * multiplier = unit)")
    def __str__(self):
        return self.unit
    class Meta:
        ordering = ('name', )
        verbose_name = _("Unit")
        verbose_name_plural = _("Units")

class UnitToServiceType(NameDescrModel):
    """
    Units suitable for usage by each separate service type
    """
    unit = models.ForeignKey('Unit', verbose_name="Unit", help_text="Units of measure")
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type", help_text="Service type linked to current term")
    def __str__(self):
        return '%s - %s' % (self.unit, self.service_type)
    class Meta:
        ordering = ('service_type__name', )
        verbose_name = _("Unit to service type")
        verbose_name_plural = _("Units to service types")

class Criterion(NameDescrModel):
    """
    This table represent information about possible criteria: >, >=, =, <=, <
    """
    def __str__(self):
        return self.name
    class Meta:
        ordering = ('name', )
        verbose_name = _("Criterion")
        verbose_name_plural = _("Criteria")

class LocationType(NameDescrModel):
    def __str__(self):
        return self.name
    class Meta:
        ordering = ('name', )
        verbose_name = _("Location Type")
        verbose_name_plural = _("Location Types")

class Location(NameDescrModel):
    included_in = models.ForeignKey('self', null=True, blank=True, verbose_name="Included in Location",
                                    help_text="Reference to Location where current is included in")
    location_type = models.ForeignKey('LocationType', verbose_name="Location Type",
                                    help_text="Location type: Country, Area, Reqion etc.")
    class Meta:
        unique_together = (("name", "included_in"),)
        ordering = ('location_type__name', 'name', )
        verbose_name = _("Location")
        verbose_name_plural = _("Locations")

class ServiceType(NameDescrAutoGeneratedModel):
    is_displayed = models.BooleanField(default=False, verbose_name="Is Displayed on Main Form", help_text="Specifies whether to display this service type on the user-inout form or not.")
    def __str__(self):
        return self.name
    def get_name(self):
        return self.name
    class Meta:
        unique_together = (('name', ), )
        ordering = ('is_displayed', 'name', )
        verbose_name = _("Service Type")
        verbose_name_plural = _("Service Types")

class Direction(NameDescrAutoGeneratedModel):
    from_location = models.ForeignKey('Location', related_name="from_directions", verbose_name="From Location",
                                    help_text="Location where you use service: call, internet etc.")
    to_location = models.ForeignKey('Location', related_name="to_directions", null=True, blank=True, verbose_name="To Location",
                                    help_text="Location where you make a call, send message etc.")
    to_operator = models.ForeignKey('Operator', verbose_name="To Operator", null=True, blank=True,
                                    help_text="Destination operator, who will receive call or message")
    def __str__(self):
        res_str = "%(from_loc)s" % {'from_loc' : self.from_location}
        if (self.to_location):
            res_str += " -> %(to_loc)s" % {'to_loc' : self.to_location}
        if (self.to_operator):
            res_str += " (%(to_oper)s)" % {'to_oper' : self.to_operator}
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        unique_together = (("from_location", "to_location", "to_operator"),)
        ordering = ('from_location__name', 'to_location__name', 'to_operator__name', )
        verbose_name = _("Direction")
        verbose_name_plural = _("Directions")

class Service(NameDescrAutoGeneratedModel):
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type",
                                     help_text="Service Type: call, SMS, internet etc.")
    direction = models.ForeignKey('Direction', verbose_name="Direction",
                                  help_text="Direction of the call, SMS, internet etc.")
    def __str__(self):
        return self.name
    def get_name(self):
        return self.__str__()
    class Meta:
        unique_together = (("service_type", "direction"),)
        ordering = ('service_type__name', 'name', )
        verbose_name = _("Service")
        verbose_name_plural = _("Services")

class Feature(NameDescrAutoGeneratedModel):
    offer = models.ForeignKey('Offer', verbose_name="Offer", null=True, blank=True, help_text="Related Offer")
    package = models.ForeignKey('Package', verbose_name="Package", null=True, blank=True, help_text="Related Package")
    service = models.ForeignKey('Service', verbose_name="Service", help_text="Provided service in scope of this feature")
    def __str__(self):
        res_str = "%(service)s" % {'service' : self.service}
        if self.offer:
            res_str += " (offer: %(offer)s" % {'offer' : self.offer}
        if self.package:
            res_str += " " if self.offer else " ("
            res_str += "package: %(package)s " % {'package' : self.package}
        if self.offer or self.package:
            res_str += ")"
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        unique_together = (("offer", "service"),)
        ordering = ('service__name', 'offer__name', 'package__name', )
        verbose_name = _("Feature")
        verbose_name_plural = _("Features")

class Attribute(NameDescrModel):
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type",
                                     help_text="Service Type that can have such attribute")
    unit = models.ForeignKey('Unit', help_text="Measurement units linked with current attribute")
    class Meta:
        unique_together = (("service_type", "name"),)
        ordering = ('name', 'service_type__name', )
        verbose_name = _("Attribute")
        verbose_name_plural = _("Attributes")

class Param(NameDescrAutoGeneratedModel):
    attr = models.ForeignKey('Attribute', verbose_name="Attribute", help_text="Reference to Attribute")
    value = models.CharField(max_length=500, null = True, blank=True, help_text="Value of parameter")
    feature = models.ForeignKey('Feature', verbose_name="Feature", help_text="Reference to Feature" )
    def __str__(self):
        ret_str = "%(attr)s" % {'attr' : self.attr}
        if self.value:
            ret_str += " = %(val)s" % {'val' : self.value}
        return ret_str
    def get_name(self):
        return "%(feature)s - %(str)s" % {'feature' : self.feature, 'str' : self.__str__()}
    class Meta:
        ordering = ('feature__name', 'attr__name', 'value', )
        verbose_name = _("Parameter")
        verbose_name_plural = _("Parameters")

class Directory(NameDescrAutoGeneratedModel):
    key = models.CharField(max_length=200, help_text="Name of the key")
    value = models.TextField(help_text="Value of current key")
    changed_date = models.DateTimeField(auto_now=True, help_text="Date when current key was changed last time")
    def get_name(self):
        return "%(key)s" % {'key' : self.key}
    class Meta:
        ordering = ('key', 'changed_date', )
        verbose_name_plural = _("Directory")
        verbose_name_plural = _("Directory Item")
