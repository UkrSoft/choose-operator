__author__ = 'Kostiantyn Bezverkhyi'

from django.core.urlresolvers import NoReverseMatch, reverse
from django.db import models

class DescriptionModel(models.Model):
    description = models.TextField(blank = True, help_text="Any useful information which may be helpful to easily operate current object.")
    def get_admin_url(self):
        """
        Returns the admin URL to edit the object represented by this log entry.
        """
        if self._meta.app_label and self._meta.model_name:
            info = (self._meta.app_label, self._meta.model_name)
            try:
                return reverse('admin:%s_%s_change' % info, args=(self.pk,))
            except NoReverseMatch:
                pass
        return None
    def get_absolute_url(self):
        return self.get_admin_url()#'http://' + get_absolute_url() + self.get_admin_url()
    def get_absolute_url_link(self):
        return '<a href="%(link)s">%(text)s</a>' % {'link' : self.get_absolute_url(), 'text' : self.__str__()}
    get_absolute_url_link.description = 'URL'
    get_absolute_url_link.allow_tags = True
    def gab(self):#shortcut for self.get_absolute_url_link()
        return self.get_absolute_url_link()
    gab.short_description = 'Object'
    gab.allow_tags = True
    def get_pk(self):
        return self.pk
    get_pk.short_description = 'ID'
    def remove(self):
        return '<a class="inline-deletelink" title="delete" href="%s/delete/"></a>' % (self.pk)
    remove.short_description = ''
    remove.allow_tags = True
    class Meta:
        abstract = True

class NameDescrModel(DescriptionModel):
    name = models.CharField(max_length=200, help_text="Name of the current object.")
    def __str__(self):
        return self.name
    class Meta:
        abstract = True

class NameDescrAutoGeneratedModel(DescriptionModel):
    name = models.CharField(max_length=200, default="<auto-generated>", editable=False, help_text="Name of the current object.")
    def save(self, *args, **kwargs):
        if self.get_name():
            self.name = self.get_name()
        super(NameDescrAutoGeneratedModel, self).save(*args, **kwargs)
    class Meta:
        abstract = True

class Code(NameDescrModel):
    operator_code = models.CharField(max_length=10,
                                     help_text="Operator code - several first digits of phone number for some specific operator")
    operator = models.ForeignKey('Operator', related_name='code',
                                 help_text="Reference to operator which uses current code.")
    def __str__(self):
        return self.operator_code

class Operator(NameDescrModel):
    location = models.ForeignKey('Location', verbose_name="Location",
                                 help_text="Reference to location where this operator provides services.")#TODO location could me multiple??
    link = models.TextField(blank=True, help_text="Link to the site where current operator resides.")
    class Meta:
        unique_together = (("name", "location"),)

class PackageType(NameDescrModel):
    pass

class Package(NameDescrModel):
    price = models.DecimalField("Initial price", max_digits=7, decimal_places=2, default=0, help_text="Initial price of package. Price that you pay when buy a new sim-card.")
    operator = models.ForeignKey('Operator', related_name='package', verbose_name="Operator",
                                 help_text="Reference to related Operator.")
    package_type = models.ForeignKey('PackageType', verbose_name='Package Type',
                                     help_text="Some specific Package Type: Prepayment, Contract, Business etc.")
    po_term = models.ForeignKey('POTerm', verbose_name='Package/Offer Term', null=True, blank=True,
                                help_text="Time term of package usage/order")
    link = models.TextField(blank=True, help_text="Link to the site with current package")
    class Meta:
        unique_together = (("name", "operator"),)
        ordering = ('package_type__name', 'operator__name', )

class Offer(NameDescrModel):
    package = models.ManyToManyField('Package', verbose_name="Package", help_text="Reference to related package")
    po_term = models.ForeignKey('POTerm', verbose_name='Package / Offer Term', help_text="Time term of offer usage/order")
    link = models.TextField(blank=True)
    def packages(self):
        return ", ".join(p.name for p in self.package.all())
    class Meta:
        ordering = ('name', 'po_term__is_active')

class POTerm(NameDescrAutoGeneratedModel):
    active_from_date = models.DateField(null=True, blank=True, verbose_name="Active from", help_text="Package/Offer is in service from this date")
    active_to_date = models.DateField(null=True, blank=True, verbose_name="Active to", help_text="Package/Offer is in service this this date")
    order_from_date = models.DateField(null=True, blank=True, verbose_name="Order from", help_text="Package/Offer can be bought from this date")
    order_to_date = models.DateField(null=True, blank=True, verbose_name="Order to", help_text="Package/Offer can be bought till this date")
    is_active = models.BooleanField(default=True, help_text="Whether this term is in use or not")
    def __str__(self):
        if not self.is_active:
            return 'Not active'
        res_str = 'Active '
        if self.active_from_date:
            if self.active_to_date:
                res_str += ' from %s to %s' % (self.active_from_date, self.active_to_date)
            else:
                res_str += ' from %s' % (self.active_from_date)
        else:
            res_str += ' forever'
        if self.order_from_date:
            res_str += ' order '
            if self.order_to_date:
                res_str += ' from %s to %s' % (self.order_from_date, self.order_to_date)
            else:
                res_str += ' from %s' % (self.order_from_date)
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        verbose_name = "Package / Offer Term"
        verbose_name_plural = "Package / Offer Terms"
        ordering = ('-active_to_date', 'active_from_date', )

class Period(NameDescrModel):
    num_of_days = models.IntegerField("Number of days for period", null=True, blank=True, help_text="Number of day for current period.")#TODO why fields are of DateTime type instead of Date??
    from_time = models.DateTimeField(null=True, blank=True,
                                     help_text="Period of time when Offer/Feature is active. For example: from 01.00")
    to_time = models.DateTimeField(null=True, blank=True,
                                   help_text="Period of time when Offer/Feature is active. For example: to 08.00")
    def __str__(self):
        res_str = self.name
        if (self.from_time or self.to_time):
            res_str+='(%(from)s to %(to)s)' % {'from' : self.from_time.date() if self.from_time else '<->', 'to' : self.to_time.date() if self.to_time else '<->'}
        return res_str
    class Meta:
        ordering = ('-to_time', 'num_of_days', )

class Payment(NameDescrAutoGeneratedModel):
    price = models.DecimalField("Price", max_digits=7, decimal_places=2, default=0, help_text="Price of Offer/Feature")
    period = models.ForeignKey('Period', null=True, blank = True, help_text="Reference to Period for current Offer/Feature")
    term_of_usage = models.ForeignKey('TermOfUsage', null=True, blank = True, help_text="Reference to Term Of Usage")
    feature = models.ForeignKey('Feature', null=True, blank=True, help_text="Reference to Feature")
    offer = models.ForeignKey('Offer', null=True, blank=True, help_text="Reference to Offer")
    depends_on = models.ManyToManyField('self', verbose_name="Depends On", blank=True, help_text="Other payments this one depends on")
    def __str__(self):
        ret_str = "Price"
        if self.offer:
            ret_str += " of %(offer)s" % {'offer' : self.offer}
        if self.feature:
            ret_str += " (%(feature)s)" % {'feature' : self.feature}
        if self.period:
            ret_str += " for %(period)s" % {'period' : self.period}
        if self.depends_on_str():
            ret_str += " depends on %(depends)s" % {'depends' : self.depends_on_str()}
        return ret_str
    def depends_on_str(self):
        return ', '.join(val['name'] for val in self.depends_on.all().values('name'))
    depends_on_str.short_description = 'Depends on (String)'
    def get_name(self):
        return self.__str__()
    class Meta:
        ordering = ('price', 'feature__offer__name', 'offer__name', )

class TermOfUsage(NameDescrAutoGeneratedModel):
    """
    This table represents possible terms of using some feature/offer. For example: 10 first minutes for one price, 11 and next minutes have another price; or 100 free minutes to another operator after ordering of super-internet package (another one offering/feature)
    """
    amount = models.IntegerField("Amount", help_text="Limit to the amount of some service")
    unit = models.ForeignKey('Unit', verbose_name="Measurement Units", help_text="Measurement units for the amount field value.")
    criterion = models.ForeignKey('Criterion', verbose_name="Criterion",
                                  help_text="Criterion to evaluate, if set to 'true' -> use current term")
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type", help_text="Service type linked to current term")
    def __str__(self):
        return '%(criterion)s %(amount)s %(unit)s (%(st)s)' % {'criterion' : self.criterion, 'amount' : self.amount, 'unit' : self.unit, 'st' : self.service_type}
    def get_name(self):
        return self.__str__()
    class Meta:
        verbose_name_plural = "Terms of Usage"
        ordering = ('criterion__name', 'amount', 'unit')

class Unit(NameDescrModel):
    unit = models.CharField(max_length=200, verbose_name="Unit", help_text="Units used for measurement")
    compared_to = models.ForeignKey('self', related_name="linked_unit", null=True, blank=True, verbose_name="Compared to unit", help_text="If compare this unit to another one")
    multiplier = models.FloatField(default=1, verbose_name="Multiply 'compared to unit'", help_text="Multiplier used to compare to values (formula is : compared_to * multiplier = unit)")
    def __str__(self):
        return self.unit
    class Meta:
        ordering = ('name', )

class UnitToServiceType(NameDescrModel):
    """
    Units suitable for usage by each separate service type
    """
    unit = models.ForeignKey('Unit', verbose_name="Unit", help_text="Units of measure")
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type", help_text="Service type linked to current term")
    def __str__(self):
        return '%s - %s' % (self.unit, self.service_type)
    class Meta:
        verbose_name_plural = "Units to service types"
        ordering = ('service_type__name', )

class Criterion(NameDescrModel):
    """
    This table represent information about possible criteria: >, >=, =, <=, <
    """
    def __str__(self):
        return self.name
    class Meta:
        verbose_name_plural = "Criteria"
        ordering = ('name', )

class LocationType(NameDescrModel):
    def __str__(self):
        return self.name
    class Meta:
        ordering = ('name', )

class Location(NameDescrModel):
    included_in = models.ForeignKey('self', null=True, blank=True, verbose_name="Included in Location",
                                    help_text="Reference to Location where current is included in")
    location_type = models.ForeignKey('LocationType', verbose_name="Location Type",
                                    help_text="Location type: Country, Area, Reqion etc.")
    class Meta:
        unique_together = (("name", "included_in"),)
        ordering = ('location_type__name', 'name', )

class ServiceType(NameDescrAutoGeneratedModel):
    is_displayed = models.BooleanField(default=False, verbose_name="Is Displayed on Main Form", help_text="Specifies whether to display this service type on the user-inout form or not.")
    def __str__(self):
        return self.name
    def get_name(self):
        return self.name
    class Meta:
        unique_together = (('name', ), )
        ordering = ('is_displayed', 'name', )

class Direction(NameDescrAutoGeneratedModel):
    from_location = models.ForeignKey('Location', related_name="from_directions", verbose_name="From Location",
                                    help_text="Location where you use service: call, internet etc.")
    to_location = models.ForeignKey('Location', related_name="to_directions", null=True, blank=True, verbose_name="To Location",
                                    help_text="Location where you make a call, send message etc.")
    to_operator = models.ForeignKey('Operator', verbose_name="To Operator", null=True, blank=True,
                                    help_text="Destination operator, who will receive call or message")
    def __str__(self):
        res_str = "%(from_loc)s" % {'from_loc' : self.from_location}
        if (self.to_location):
            res_str += " -> %(to_loc)s" % {'to_loc' : self.to_location}
        if (self.to_operator):
            res_str += " (%(to_oper)s)" % {'to_oper' : self.to_operator}
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        unique_together = (("from_location", "to_location", "to_operator"),)
        ordering = ('from_location__name', 'to_location__name', 'to_operator__name', )

class Service(NameDescrAutoGeneratedModel):
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type",
                                     help_text="Service Type: call, SMS, internet etc.")
    direction = models.ForeignKey('Direction', verbose_name="Direction",
                                  help_text="Direction of the call, SMS, internet etc.")
    def __str__(self):
        return self.name
    def get_name(self):
        return self.__str__()
    class Meta:
        unique_together = (("service_type", "direction"),)
        ordering = ('service_type__name', 'name', )

class Feature(NameDescrAutoGeneratedModel):
    offer = models.ForeignKey('Offer', verbose_name="Offer", null=True, blank=True, help_text="Related Offer")
    package = models.ForeignKey('Package', verbose_name="Package", null=True, blank=True, help_text="Related Package")
    service = models.ForeignKey('Service', verbose_name="Service", help_text="Provided service in scope of this feature")
    def __str__(self):
        res_str = "%(service)s" % {'service' : self.service}
        if self.offer:
            res_str += " (offer: %(offer)s" % {'offer' : self.offer}
        if self.package:
            res_str += " " if self.offer else " ("
            res_str += "package: %(package)s " % {'package' : self.package}
        if self.offer or self.package:
            res_str += ")"
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        unique_together = (("offer", "service"),)
        ordering = ('service__name', 'offer__name', 'package__name', )

class Attribute(NameDescrModel):
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type",
                                     help_text="Service Type that can have such attribute")
    unit = models.ForeignKey('Unit', help_text="Measurement units linked with current attribute")
    class Meta:
        unique_together = (("service_type", "name"),)
        ordering = ('name', 'service_type__name', )

class Param(NameDescrAutoGeneratedModel):
    attr = models.ForeignKey('Attribute', verbose_name="Attribute", help_text="Reference to Attribute")
    value = models.CharField(max_length=500, null = True, blank=True, help_text="Value of parameter")
    feature = models.ForeignKey('Feature', verbose_name="Feature", help_text="Reference to Feature" )
    def __str__(self):
        ret_str = "%(attr)s" % {'attr' : self.attr}
        if self.value:
            ret_str += " = %(val)s" % {'val' : self.value}
        return ret_str
    def get_name(self):
        return "%(feature)s - %(str)s" % {'feature' : self.feature, 'str' : self.__str__()}
    class Meta:
        verbose_name = "Parameter"
        verbose_name_plural = "Parameters"
        ordering = ('feature__name', 'attr__name', 'value', )

class Directory(NameDescrAutoGeneratedModel):
    key = models.CharField(max_length=200, help_text="Name of the key")
    value = models.TextField(help_text="Value of current key")
    changed_date = models.DateTimeField(auto_now=True, help_text="Date when current key was changed last time")
    def get_name(self):
        return "%(key)s" % {'key' : self.key}
    class Meta:
        verbose_name_plural = "Directory"
        ordering = ('key', 'changed_date', )
