__author__ = 'Kostiantyn Bezverkhyi'

from django.core.urlresolvers import NoReverseMatch, reverse
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.translation import ugettext as _n

class DescriptionModel(models.Model):
    description = models.TextField(blank = True, verbose_name=_("Description"), help_text=_("Any information which may be helpful to easily operate current object."))
    def get_admin_url(self):
        """
        Returns the admin URL to edit the object represented by this log entry.
        """
        if self._meta.app_label and self._meta.model_name:
            info = (self._meta.app_label, self._meta.model_name)
            try:
                return reverse('admin:%s_%s_change' % info, args=(self.pk,))
            except NoReverseMatch:
                pass
        return None
    def get_absolute_url(self):
        return self.get_admin_url()#'http://' + get_absolute_url() + self.get_admin_url()
    def get_absolute_url_link(self):
        return '<a href="%(link)s">%(text)s</a>' % {'link' : self.get_absolute_url(), 'text' : self.__str__()}
    get_absolute_url_link.description = _('URL')
    get_absolute_url_link.allow_tags = True
    def gab(self):#shortcut for self.get_absolute_url_link()
        return self.get_absolute_url_link()
    gab.short_description = _('Object')
    gab.allow_tags = True
    def get_pk(self):
        return self.pk
    get_pk.short_description = _('ID')
    def remove(self):
        return '<a class="inline-deletelink" title="delete" href="%s/delete/"></a>' % (self.pk)
    remove.short_description = ''
    remove.allow_tags = True
    class Meta:
        abstract = True

class NameDescrModel(DescriptionModel):
    name = models.CharField(max_length=200, verbose_name=_("Name"), help_text=_("Name of the current object."))
    def __str__(self):
        return self.name
    class Meta:
        abstract = True

class NameDescrAutoGeneratedModel(DescriptionModel):# Translators: This field should have the same name all the time?
    name = models.CharField(max_length=200, verbose_name=_("Name"), default="<auto-generated>", editable=False, help_text=_("Name of the current object."))
    def save(self, *args, **kwargs):
        if self.get_name():
            self.name = self.get_name()
        super(NameDescrAutoGeneratedModel, self).save(*args, **kwargs)
    class Meta:
        abstract = True

class Code(NameDescrModel):
    operator_code = models.CharField(max_length=10, verbose_name=_("Operator Code"),
                                     help_text=_("Operator code - several first digits of phone number for some specific operator"))
    operator = models.ForeignKey('Operator', related_name='code', verbose_name= _("Operator"),
                                 help_text=_("Reference to operator which uses current code."))
    def __str__(self):
        return self.operator_code
    class Meta:
        verbose_name = _("Code")
        verbose_name_plural = _("Codes")

class Operator(NameDescrModel):
    location = models.ForeignKey('Location', verbose_name=_("Location"),
                                 help_text=_("Reference to location where this operator provides services."))#TODO location could me multiple??
    link = models.TextField(blank=True, verbose_name=_("Link"), help_text=_("Link to the site where current operator resides."))
    class Meta:
        unique_together = (("name", "location"),)
        verbose_name = _("Operator")
        verbose_name_plural = _("Operators")

class PackageType(NameDescrModel):
    pass

class Package(NameDescrModel):
    price = models.DecimalField(_("Initial price"), max_digits=7, decimal_places=2, default=0, help_text=_("Initial price of package. Price that you pay when buy a new sim-card."))
    operator = models.ForeignKey('Operator', related_name='package', verbose_name=_("Operator"),
                                 help_text=_("Reference to related Operator."))
    package_type = models.ForeignKey('PackageType', verbose_name=_('Package Type'),
                                     help_text=_("Some specific Package Type: Prepayment, Contract, Business etc."))
    po_term = models.ForeignKey('POTerm', verbose_name=_('Package/Offer Term'), null=True, blank=True,
                                help_text=_("Time term of package usage/order"))
    link = models.TextField(blank=True, verbose_name=_("Link"), help_text=_("Site page with current package"))
    class Meta:
        unique_together = (("name", "operator"),)
        ordering = ('package_type__name', 'operator__name', )
        verbose_name = _("Package")
        verbose_name_plural = _("Packages")

class Offer(NameDescrModel):
    package = models.ManyToManyField('Package', verbose_name=_("Package"), help_text=_("Reference to related package"))
    po_term = models.ForeignKey('POTerm', verbose_name=_('Package / Offer Term'), help_text=_("Time term of offer usage/order"))
    link = models.TextField(blank=True, verbose_name=_("Link"), help_text=_("Site page with current offer"))
    def packages(self):
        return ", ".join(p.name for p in self.package.all())
    class Meta:
        ordering = ('name', 'po_term__is_active')
        verbose_name = _("Offer")
        verbose_name_plural = _("Offers")

class POTerm(NameDescrAutoGeneratedModel):
    active_from_date = models.DateField(null=True, blank=True, verbose_name=_("Active from"), help_text=_("Package/Offer is in service from this date"))
    active_to_date = models.DateField(null=True, blank=True, verbose_name=_("Active to"), help_text=_("Package/Offer is in service till this date"))
    order_from_date = models.DateField(null=True, blank=True, verbose_name=_("Order from"), help_text=_("Package/Offer can be bought from this date"))
    order_to_date = models.DateField(null=True, blank=True, verbose_name=_("Order to"), help_text=_("Package/Offer can be bought till this date"))
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"), help_text=_("Whether this term is in use or not"))
    def __str__(self):
        if not self.is_active:
            return _n('Not active')
        res_str = _n('Active')
        if self.active_from_date:
            if self.active_to_date:
                res_str += _n(" from %(from_date)s to %(to_date)s") % {'from_date' : self.active_from_date, 'to_date' : self.active_to_date}
            else:
                res_str += _n(' from %(from_date)s') % {'from_date' : self.active_from_date}
        else:
            res_str += _n(' forever')
        if self.order_from_date:
            res_str += _n(' order ')
            if self.order_to_date:
                res_str += _n(' from %(order_from)s to %(order_to)s') % {'order_from' : self.order_from_date, 'order_to' : self.order_to_date}
            else:
                res_str += ' from %s' % (self.order_from_date)
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        verbose_name = _("Package / Offer Term")
        verbose_name_plural = _("Package / Offer Terms")
        ordering = ('-active_to_date', 'active_from_date', )

class Period(NameDescrModel):
    num_of_days = models.IntegerField(_("Number of days"), null=True, blank=True, help_text=_("Number of day for current period."))#TODO why fields are of DateTime type instead of Date??
    from_time = models.DateTimeField(null=True, blank=True, verbose_name=_("From Time"),
                                     help_text=_("Period of time when Offer/Feature is active. For example: from 01.00"))
    to_time = models.DateTimeField(null=True, blank=True, verbose_name=_("To Time"),
                                   help_text=_("Period of time when Offer/Feature is active. For example: to 08.00"))
    def __str__(self):
        res_str = self.name
        if (self.from_time or self.to_time):
            res_str += _n('(%(from)s to %(to)s)') % {'from' : self.from_time.date() if self.from_time else '<->', 'to' : self.to_time.date() if self.to_time else '<->'}
        return res_str
    class Meta:
        ordering = ('-to_time', 'num_of_days', )
        verbose_name = _("Period")
        verbose_name_plural = _("Periods")

class Payment(NameDescrAutoGeneratedModel):
    price = models.DecimalField("Price", max_digits=7, decimal_places=2, default=0, help_text=_("Price of Offer/Feature"))
    period = models.ForeignKey('Period', null=True, blank = True, verbose_name=_("Period"), help_text=_("Reference to Period for current Offer/Feature"))
    term_of_usage = models.ForeignKey('TermOfUsage', null=True, blank = True, verbose_name=_("Term of Usage"), help_text=_("Reference to Term Of Usage"))
    feature = models.ForeignKey('Feature', null=True, blank=True, verbose_name=_("Feature"), help_text=_("Reference to Feature"))
    offer = models.ForeignKey('Offer', null=True, blank=True, verbose_name=_("Offer"), help_text=_("Reference to Offer"))
    def __str__(self):
        res_str = "Price"
        if self.offer:
            res_str += _n(" of %(offer)s") % {'offer' : self.offer}
        if self.feature:
            res_str += " (%(feature)s)" % {'feature' : self.feature}
        if self.period:
            res_str += _n(" for %(period)s") % {'period' : self.period}
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        ordering = ('price', 'feature__offer__name', 'offer__name', )
        verbose_name = _("Payment")
        verbose_name_plural = _("Payments")

class TermOfUsage(NameDescrAutoGeneratedModel):
    """
    This table represents possible terms of using some feature/offer. For example: 10 first minutes for one price, 11 and next minutes have another price
    """
    amount = models.IntegerField(_("Amount"), help_text=_("Limit to the amount of some service"))
    unit = models.ForeignKey('Unit', verbose_name=_("Measurement Units"), help_text=_("Measurement units for the amount field value."))
    criterion = models.ForeignKey('Criterion', verbose_name=_("Criterion"),
                                  help_text=_("Criterion to evaluate, if set to 'true' -> use current term"))
    service_type = models.ForeignKey('ServiceType', verbose_name=_("Service Type"), help_text=_("Service type linked to current term"))
    def __str__(self):
        return '%(criterion)s %(amount)s %(unit)s (%(st)s)' % {'criterion' : self.criterion, 'amount' : self.amount, 'unit' : self.unit, 'st' : self.service_type}
    def get_name(self):
        return self.__str__()
    class Meta:
        ordering = ('criterion__name', 'amount', 'unit')
        verbose_name = _("Term Of Usage")
        verbose_name_plural = _("Terms Of Usage")

class Unit(NameDescrModel):
    unit = models.CharField(max_length=200, verbose_name=_("Unit"), help_text=_("Units used for measurement"))
    compared_to = models.ForeignKey('self', related_name="linked_unit", null=True, blank=True, verbose_name=_("Compared to unit"), help_text=_("If compare this unit to another one"))
    multiplier = models.FloatField(default=1, verbose_name=_("Multiply 'compared to unit'"), help_text=_("Multiplier used to compare to values (formula is : compared_to * multiplier = unit)"))
    def __str__(self):
        return self.unit
    class Meta:
        ordering = ('name', )
        verbose_name = _("Unit")
        verbose_name_plural = _("Units")

class UnitToServiceType(NameDescrModel):
    """
    Units suitable for usage by each separate service type
    """
    unit = models.ForeignKey('Unit', verbose_name="Unit", help_text="Units of measure")
    service_type = models.ForeignKey('ServiceType', verbose_name="Service Type", help_text="Service type linked to current term")
    def __str__(self):
        return '%s - %s' % (self.unit, self.service_type)
    class Meta:
        ordering = ('service_type__name', )
        verbose_name = _("Unit to service type")
        verbose_name_plural = _("Units to service types")

class Criterion(NameDescrModel):
    """
    This table represent information about possible criteria: >, >=, =, <=, <
    """
    def __str__(self):
        return self.name
    class Meta:
        ordering = ('name', )
        verbose_name = _("Criterion")
        verbose_name_plural = _("Criteria")

class LocationType(NameDescrModel):
    def __str__(self):
        return self.name
    class Meta:
        ordering = ('name', )
        verbose_name = _("Location Type")
        verbose_name_plural = _("Location Types")

class Location(NameDescrModel):
    included_in = models.ForeignKey('self', null=True, blank=True, verbose_name=_("Included in Location"),
                                    help_text=_("Reference to Location where current is included in"))
    location_type = models.ForeignKey('LocationType', verbose_name=_("Location Type"),
                                    help_text=_("Location type: Country, Area, Region etc."))
    class Meta:
        unique_together = (("name", "included_in"),)
        ordering = ('location_type__name', 'name', )
        verbose_name = _("Location")
        verbose_name_plural = _("Locations")

class ServiceType(NameDescrAutoGeneratedModel):
    is_displayed = models.BooleanField(default=False, verbose_name=_("Is Displayed on Main Form"), help_text=_("Specifies whether to display this service type on the user-input form or not."))
    def __str__(self):
        return self.name
    def get_name(self):
        return self.name
    class Meta:
        unique_together = (('name', ), )
        ordering = ('is_displayed', 'name', )
        verbose_name = _("Service Type")
        verbose_name_plural = _("Service Types")

class Direction(NameDescrAutoGeneratedModel):
    from_location = models.ForeignKey('Location', related_name="from_directions", verbose_name=_("From Location"),
                                    help_text=_("Location where you use service: call, internet etc."))
    to_location = models.ForeignKey('Location', related_name="to_directions", null=True, blank=True, verbose_name=_("To Location"),
                                    help_text=_("Location where you make a call, send message etc."))
    to_operator = models.ManyToManyField('Operator', verbose_name=_("To Operator"), blank=True, help_text=_("Destination operator, who will receive call or message"))
    to_operators = models.TextField(max_length=300, editable=False, verbose_name=_("To Operators (String)"), blank=True, null=True, help_text=_("Concatenation of operators selected in 'to_operator' field"))
    def __str__(self):
        res_str = "%(from_loc)s" % {'from_loc' : self.from_location}
        if (self.to_location):
            res_str += " -> %(to_loc)s" % {'to_loc' : self.to_location}
        if (self.to_operators_str()):
            res_str += " (%(to_oper)s)" % {'to_oper' : self.to_operators_str()}
        return res_str
    def save(self, *args, **kwargs):
        self.to_operators = self.to_operators_str()
        super(Direction, self).save(*args, **kwargs)
    def get_name(self):
        return self.__str__()
    def to_operators_str(self):
        return ', '.join(val['name'] for val in self.to_operator.values('name'))
    class Meta:
        unique_together = (("from_location", "to_location", "to_operators"),)
        ordering = ('from_location__name', 'to_location__name', 'to_operators', )
        verbose_name = _("Direction")
        verbose_name_plural = _("Directions")

class Service(NameDescrAutoGeneratedModel):
    service_type = models.ForeignKey('ServiceType', verbose_name=_("Service Type"),
                                     help_text=_("Service Type: call, SMS, internet etc."))
    direction = models.ForeignKey('Direction', verbose_name=_("Direction"),
                                  help_text=_("Direction of the call, SMS, internet etc."))
    def __str__(self):
        return self.name
    def get_name(self):
        return self.__str__()
    class Meta:
        unique_together = (("service_type", "direction"),)
        ordering = ('service_type__name', 'name', )
        verbose_name = _("Service")
        verbose_name_plural = _("Services")

class Feature(NameDescrAutoGeneratedModel):
    offer = models.ForeignKey('Offer', verbose_name=_("Offer"), null=True, blank=True, help_text=_("Related Offer"))
    package = models.ForeignKey('Package', verbose_name=_("Package"), null=True, blank=True, help_text=_("Related Package"))
    service = models.ForeignKey('Service', verbose_name=_("Service"), help_text=_("Provided service in scope of this feature"))
    def __str__(self):
        res_str = "%(service)s" % {'service' : self.service}
        if self.offer:
            res_str += _n(" (offer: %(offer)s") % {'offer' : self.offer}
        if self.package:
            res_str += " " if self.offer else " ("
            res_str += _n("package: %(package)s ") % {'package' : self.package}
        if self.offer or self.package:
            res_str += ")"
        return res_str
    def get_name(self):
        return self.__str__()
    class Meta:
        unique_together = (("offer", "service"),)
        ordering = ('service__name', 'offer__name', 'package__name', )
        verbose_name = _("Feature")
        verbose_name_plural = _("Features")

class Attribute(NameDescrModel):
    service_type = models.ForeignKey('ServiceType', verbose_name=_("Service Type"),
                                     help_text=_("Service Type that can have such attribute"))
    unit = models.ForeignKey('Unit', verbose_name=_('Unit'), help_text=_("Measurement units linked with current attribute"))
    class Meta:
        unique_together = (("service_type", "name"),)
        ordering = ('name', 'service_type__name', )
        verbose_name = _("Attribute")
        verbose_name_plural = _("Attributes")

class Param(NameDescrAutoGeneratedModel):
    attr = models.ForeignKey('Attribute', verbose_name=_("Attribute"), help_text=_("Reference to Attribute"))
    value = models.CharField(max_length=500, null = True, blank=True, verbose_name=_("Value"), help_text=_("Value of parameter"))
    feature = models.ForeignKey('Feature', verbose_name=_("Feature"), help_text=_("Reference to Feature" ))
    def __str__(self):
        res_str = "%(attr)s" % {'attr' : self.attr}
        if self.value:
            res_str += " = %(val)s" % {'val' : self.value}
        return "%(feature)s - %(str)s" % {'feature' : self.feature, 'str' : res_str}
    def get_name(self):
        return self.__str__()
    class Meta:
        ordering = ('feature__name', 'attr__name', 'value', )
        verbose_name = _("Parameter")
        verbose_name_plural = _("Parameters")

class Directory(NameDescrAutoGeneratedModel):
    key = models.CharField(max_length=200, verbose_name=_('Key'), help_text=_("Name of the key"))
    value = models.TextField(verbose_name=_('Value'), help_text=_("Value of current key"))
    changed_date = models.DateTimeField(auto_now=True, verbose_name=_('Changed when'), help_text=_("Date when current key was changed last time"))
    def get_name(self):
        return "%(key)s" % {'key' : self.key}
    class Meta:
        ordering = ('key', 'changed_date', )
        verbose_name_plural = _("Directory")
        verbose_name_plural = _("Directory Item")
